---
TimeLine: 
=> 20220328--0000000 : 章节已创建

---

| #未完成-正文 | #未完成-习题 | #FIXING |
| ------------ | ------------ | ----- |

# 序数和基数

## ::MACRO

| IMPORT | DESCRIPTION |
| ------ | ----------- |
|        |             |

## 预序集

预序关系是指满足反身性(第 $(1)$ 式)和传递性(第 $(2)$ 式)的关系, 定义了预序关系的集合称为预序集. 

$$
\text{pre-ordered}(X):=
\Field{(\and)}{\;\;}{
    \\
    & (\le):= X[\le]\\
    \\
    & X[\S]\text{<set>}\\
    & (\le):X[\S]\times X[\S]\to \{true,false\}\\
    \\
    & x \le x 
        & \cdots (1)\\
    & x \le y \and y \le z \Rarrow x\le z 
        & \cdots (2)\\
    \\
}
$$

为了方便起见,  再添加下述三个定义

$$
\begin{matrix}
X\left[\begin{aligned}
    \\
    (<) & :: \Field{(\and)}{\;\;}{
        & (<):\S\times \S\to \{true,false\}\\
        & x < y \Leftrightarrow x \le y \and x \ne y
    }\\\\
    (\ge) & :: \Field{(\and)}{\;\;}{
        & (\ge):\S\times \S\to \{true,false\}\\
        & x\ge y \Leftrightarrow y \le x
    }\\\\
    (>) & :: \Field{(\and)}{\;\;}{
        & (>):\S\times \S\to \{true,false\}\\
        & x > y \Leftrightarrow x \ge y \and x \ne y
    }\\\\
\end{aligned}\right]\\ 
:::\text{pre-ordered}(X)\\
\end{matrix}
$$

## 偏序集

偏序关系是指在预序集上添加了反对称性的关系, 它使得两个元素之间不能既严格大于一个元素又严格小于一个元素. 

$$
\text{partially-ordered}(X):=
\Field{(\and)}{\;\;}{
    \\
    & (\le):= X[\le]\\
    \\
    & X[\S]\text{<set>}\\
    & (\le):X[\S]\times X[\S]\to \{true,false\}\\
    \\
    & x \le x
        & \cdots (1)\\
    & x \le y \and y \le x\Rarrow x=y
        & \cdots (2)\\
    & x \le y \and y \le z\Rarrow x\le z 
        & \cdots (3)\\
    \\
}
$$

## 全序集

全序关系或者线序关系, 是指任意两个元素之间总是可以分出大小. 取出任意多个元素时, 总能从小到大排成一条线. 

形式化表达中将偏序关系的 $(2)$ 式替换掉即得到全序关系, $(2)$ 式约束使得任意两个元素大于,小于,和相等三种关系必取且仅取一种. 

$$
\text{serially-ordered}(X):=
\Field{(\and)}{\;\;}{
    \\
    & (\le):= X[\le]\\
    \\
    & X[\S]\text{<set>}\\
    & (\le):X[\S]\times X[\S]\to \{true,false\}\\
    \\
    & x \le x
        & \cdots (1)\\
    & (x = y) \or (x \le y \and \neg y \le x) \or (\neg x \le y \and y \le x)  
        & \cdots (2)\\
    & (x \le y) \and (y \le z)\Rarrow (x\le z) 
        & \cdots (3)\\
    \\
}
$$

## 基数的定义

## Schröder–Bernstein 定理

文字说明: 

如果存在一个函数 $f: X \to Y$ 是单射, 而且存在一个函数 $g: Y\to X$ 是单射, 那么我们断言 $X$ 和 $Y$ 之间存在一个双射. 

形式说明: 
$$
\FieldEndl{
    & \forall X,Y\text{<set>}:\\
}{\;\;}{
    & \CondBegin\\
    & \exist f: X \to Y: f\text{<inj>}\\
    & \exist g: Y \to X: g\text{<inj>}\\
    & \CondEnd\\
    & \exist h: X \to Y: h\text{<inj>} \and \hat h(X) = Y
}
$$

文字证明: 

我们希望能够选出一些点使用映射 $f$ , 选出一些点使用映射 $g^{\diamond-}$ 使得它们之间值域不相交但是映满 $Y$, 这样就能找到所求的双射. 

考虑这个问题的诀窍是观察什么地方是只能使用 $f$ 或者只能使用 $g^{\diamond-}$ 的, 先把这些地方决定下来, 而如果在这当中已经出现冲突, 也就意味着这个想法应该作废了(仔细考虑的话会发现这不可能发生). 

我们注意到, $g^{\diamond-}$ 的定义域不能触及的地方只能用 $f$ , 故 $X \diagdown \hat g(Y)$ 上使用 $f$, 对应的值域是 $\hat f(X \diagdown \hat g(Y))=\hat f(X) \diagdown \hat f(\hat g(Y))$

而对称地考虑 $f$ 的值域不能触及的地方, 只能用 $g^{\diamond-}$, 故 $\hat g(Y \diagdown \hat f(X))=\hat g(Y) \diagdown \hat g(\hat f(X))$ 上使用 $g^{\diamond-}$, 对应的值域是 $Y \diagdown \hat f(X)$

我们发现, $X$ 和 $Y$ 上未被决定的点分别还剩下 $\hat g(\hat f(X))$ 和 $\hat f(\hat g(Y))$, 而容易验证

$$
\begin{matrix}
f\bigg|_{\hat g(\hat f(X))}: \hat g(\hat f(X))\to \hat f(\hat g(Y))\\
g\bigg|_{\hat f(\hat g(Y))}: \hat f(\hat g(Y)) \to \hat g(\hat f(X))
\end{matrix}
$$ 

![S-B_Theorem_Visualized_Proof|800](S-B_Theorem_Visualized_Proof.svg)

这使得我们的题设递归地跑到了 $\hat g(\hat f(X))$ 和 $\hat f(\hat g(Y))$ 上面, 我们不妨定义迭代方法: 

$$
\begin{matrix}
X_{(n+1)} = \hat g(\hat f(X_{(n)}))\\
X_{(1)} = X\\
Y_{(n+1)} = \hat f (\hat g(Y_{(n)}))\\
Y_{(1)} = Y
\end{matrix}
$$

而易知 $X_{(n)} \diagdown X_{(n+1)}$ 和 $Y_{(n)}\diagdown Y_{(n+1)}$ 之间 $\hat g(Y_{(n)})\diagdown X_{(n+1)}$ 上 $g^{\diamond-}$ 是双射, 而 $X_{(n)} \diagdown \hat g(Y_{(n)})$ 上 $f$ 是双射. 

不同于算法设计当中我们处理的离散问题, 此处我们必须注意下面两个可列交当中的点(即使 $X_{(n+1)} \subsetneq X_{(n)}$ 总是成立): 

$$
\bigcap\limits_{n\in [1 ..]} X_{(n)}, \bigcap_{n\in [1 ..]} Y_{(n)}
$$
注意到从 $Y_{(2)}$ 开始往后的 $Y_{(n)}$ 都落在 $f$ 的值域中, 在 $X_{(n)}$ 的可列并上我们尝试取 $f$ 当作双射. 

已知 $f$ 是个单射, 我们现在的目标是验证 $f$ 能把 $\bigcap\limits_{n\in [1 ..]} X_{(n)}$ 恰好映满且不超出 $\bigcap\limits_{n\in [1 ..]} Y_{(n)}$. 

为此我们需要知道 $\hat f(X_{(n)})$ 和各个 $Y_{(n)}$的关系. 

比较明显的是 $\hat f(X_{(n)}) \sube Y_{(n)}$ , 这是之前 $f\bigg|_{X_{(n)}} : X_{(n)} \to Y_{(n)}$ 式验证过的. 

另一方面我们知道 $Y_{(n+1)} = \hat f(\hat g(Y_{(n)}))$ , 而 $\hat g(Y_{(n)}) \sube X_{(n)}$, 因此 $Y_{(n+1)} \sube \hat f(X_{(n)})$ . 

进而我们知道下面两式都成立, 这说明 $f$ 在最后两个可列并之间是不超也不漏的映射. 

$$
\begin{aligned}
\hat f\left(\bigcap_{n\in [1 ..]}X_{(n)}\right)
= \bigcap_{n\in [1 .. ]} \hat f\Big(X_{(n)}\Big)
\supe \bigcap_{n\in [2 ..]} Y_{(n)}\\
\hat f\left(\bigcap_{n\in [1 ..]}X_{(n)}\right)
= \bigcap_{n\in [1 .. ]} \hat f\Big(X_{(n)}\Big)
\sube \bigcap_{n\in [1 ..]} Y_{(n)}
\end{aligned}
$$ 
RMK: 其实最后的可列并上取谁都是无所谓的, 可以验证 $g^{\diamond-}$ 也是双射. 

形式证明: 

$$
\FieldEndl{
    & \forall X,Y\text{<set>}:\\
    & \# f: X \to Y \and f\text{<inj>}:\\
    & \# g: Y \to X \and g\text{<inj>}:\\
}{\;\;}{
    & \CondBegin\\
    & A::\Field{(\and)}{\;\;}{
        & A:[1..] \to \Pow(X)\\
        & A_{(n+1)} = \hat g(\hat f(A_{(n)}))\\
        & A_{(1)} = X
    }\\
    & B::\Field{(\and)}{\;\;}{
        & B:[1..] \to \Pow(Y)\\
        & B_{(n+1)} = \hat g^{\diamond-}(\hat f(\hat g(B_{(n)})))\\
        & B_{(1)} = \hat g^{\diamond-}(Y)
    }\\
    & h::\Field{(\and)}{\;\;}{
        & h: X\to Y\\
        & \forall n\in [1..]:h\bigg|_{A_{(n)}\diagdown B_{(n)}} 
        = f\bigg|_{A_{(n)}\diagdown B_{(n)}} \\
        & \forall n\in [1..]:h\bigg|_{\bigcap\limits_{n\in [1..]}A_{(n)}} 
        = f\bigg|_{\bigcap\limits_{n\in [1..]}A_{(n)}}\\
        & \forall n\in [1..]:h\bigg|_{A_{(n)}\diagdown A_{(n+1)} \cap B_{(n)}} 
        = g^{\diamond-}\bigg|_{A_{(n)}\diagdown A_{(n+1)} \cap B_{(n)}}\\
    }\\
    & h\text{<inj>} \and \hat h(X) = Y
}
$$

## Zorn 引理

## Cantor 良序定理


## aleph数的定义


***
