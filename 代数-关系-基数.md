# 基数

## Schröder–Bernstein 定理

\<文字描述\>

如果存在一个函数 $f: X \to Y$ 是单射, 而且存在一个函数 $g: Y\to X$ 是单射, 那么我们断言 $X$ 和 $Y$ 之间存在一个双射. 

\<形式描述\> 

$$
\FieldEndl{
    & \forall X,Y\text{<set>}:\\
}{\;\;}{
    & \CondBegin\\
    & \exist f: X \to Y: f\text{<inj>}\\
    & \exist g: Y \to X: g\text{<inj>}\\
    & \CondEnd\\
    & \exist h: X \to Y: h\text{<inj>} \and \hat h(X) = Y
}
$$

\<文字证明\>

我们希望能够选出一些点使用映射 $f$ , 选出一些点使用映射 $g^{\diamond-}$ 使得它们之间值域不相交但是映满 $Y$, 这样就能找到所求的双射. 

考虑这个问题的诀窍是观察什么地方是只能使用 $f$ 或者只能使用 $g^{\diamond-}$ 的, 先把这些地方决定下来, 而如果在这当中已经出现冲突, 也就意味着这个想法应该作废了(仔细考虑的话会发现这不可能发生). 

我们注意到, $g^{\diamond-}$ 的定义域不能触及的地方只能用 $f$ , 故 $X \diagdown \hat g(Y)$ 上使用 $f$, 对应的值域是 $\hat f(X \diagdown \hat g(Y))=\hat f(X) \diagdown \hat f(\hat g(Y))$

而对称地考虑 $f$ 的值域不能触及的地方, 只能用 $g^{\diamond-}$, 故 $\hat g(Y \diagdown \hat f(X))=\hat g(Y) \diagdown \hat g(\hat f(X))$ 上使用 $g^{\diamond-}$, 对应的值域是 $Y \diagdown \hat f(X)$

我们发现, $X$ 和 $Y$ 上未被决定的点分别还剩下 $\hat g(\hat f(X))$ 和 $\hat f(\hat g(Y))$, 而容易验证

$$
\begin{matrix}
f\bigg|_{\hat g(\hat f(X))}: \hat g(\hat f(X))\to \hat f(\hat g(Y))\\
g\bigg|_{\hat f(\hat g(Y))}: \hat f(\hat g(Y)) \to \hat g(\hat f(X))
\end{matrix}
$$ 

![S-B_Theorem_Visualized_Proof|800](S-B_Theorem_Visualized_Proof.svg)

这使得我们的题设递归地跑到了 $\hat g(\hat f(X))$ 和 $\hat f(\hat g(Y))$ 上面, 我们不妨定义迭代方法: 

$$
\begin{matrix}
X_{(n+1)} = \hat g(\hat f(X_{(n)}))\\
X_{(1)} = X\\
Y_{(n+1)} = \hat f (\hat g(Y_{(n)}))\\
Y_{(1)} = Y
\end{matrix}
$$

而易知 $X_{(n)} \diagdown X_{(n+1)}$ 和 $Y_{(n)}\diagdown Y_{(n+1)}$ 之间 $\hat g(Y_{(n)})\diagdown X_{(n+1)}$ 上 $g^{\diamond-}$ 是双射, 而 $X_{(n)} \diagdown \hat g(Y_{(n)})$ 上 $f$ 是双射. 

不同于算法设计当中我们处理的离散问题, 此处我们必须注意下面两个可列交当中的点(即使 $X_{(n+1)} \subsetneq X_{(n)}$ 总是成立): 

$$
\bigcap\limits_{n\in [1 ..]} X_{(n)}, \bigcap_{n\in [1 ..]} Y_{(n)}
$$
注意到从 $Y_{(2)}$ 开始往后的 $Y_{(n)}$ 都落在 $f$ 的值域中, 在 $X_{(n)}$ 的可列并上我们尝试取 $f$ 当作双射. 

已知 $f$ 是个单射, 我们现在的目标是验证 $f$ 能把 $\bigcap\limits_{n\in [1 ..]} X_{(n)}$ 恰好映满且不超出 $\bigcap\limits_{n\in [1 ..]} Y_{(n)}$. 

为此我们需要知道 $\hat f(X_{(n)})$ 和各个 $Y_{(n)}$的关系. 

比较明显的是 $\hat f(X_{(n)}) \sube Y_{(n)}$ , 这是之前 $f\bigg|_{X_{(n)}} : X_{(n)} \to Y_{(n)}$ 式验证过的. 

另一方面我们知道 $Y_{(n+1)} = \hat f(\hat g(Y_{(n)}))$ , 而 $\hat g(Y_{(n)}) \sube X_{(n)}$, 因此 $Y_{(n+1)} \sube \hat f(X_{(n)})$ . 

进而我们知道下面两式都成立, 这说明 $f$ 在最后两个可列并之间是不超也不漏的映射. 

$$
\begin{aligned}
\hat f\left(\bigcap_{n\in [1 ..]}X_{(n)}\right)
= \bigcap_{n\in [1 .. ]} \hat f\Big(X_{(n)}\Big)
\supe \bigcap_{n\in [2 ..]} Y_{(n)}\\
\hat f\left(\bigcap_{n\in [1 ..]}X_{(n)}\right)
= \bigcap_{n\in [1 .. ]} \hat f\Big(X_{(n)}\Big)
\sube \bigcap_{n\in [1 ..]} Y_{(n)}
\end{aligned}
$$ 

\<RMK\>

其实最后的可列并上取谁都是无所谓的, 可以验证 $g^{\diamond-}$ 也是双射. 

\<形式证明\>

$$
\FieldEndl{
    & \forall X,Y\text{<set>}:\\
    & \# f: X \to Y \and f\text{<inj>}:\\
    & \# g: Y \to X \and g\text{<inj>}:\\
}{\;\;}{
    & \CondBegin\\
    & A::\Field{(\and)}{\;\;}{
        & A:[1..] \to \Pow(X)\\
        & A_{(n+1)} = \hat g(\hat f(A_{(n)}))\\
        & A_{(1)} = X
    }\\
    & B::\Field{(\and)}{\;\;}{
        & B:[1..] \to \Pow(Y)\\
        & B_{(n+1)} = \hat g^{\diamond-}(\hat f(\hat g(B_{(n)})))\\
        & B_{(1)} = \hat g^{\diamond-}(Y)
    }\\
    & h::\Field{(\and)}{\;\;}{
        & h: X\to Y\\
        & \forall n\in [1..]:h\bigg|_{A_{(n)}\diagdown B_{(n)}} 
        = f\bigg|_{A_{(n)}\diagdown B_{(n)}} \\
        & \forall n\in [1..]:h\bigg|_{\bigcap\limits_{n\in [1..]}A_{(n)}} 
        = f\bigg|_{\bigcap\limits_{n\in [1..]}A_{(n)}}\\
        & \forall n\in [1..]:h\bigg|_{A_{(n)}\diagdown A_{(n+1)} \cap B_{(n)}} 
        = g^{\diamond-}\bigg|_{A_{(n)}\diagdown A_{(n+1)} \cap B_{(n)}}\\
    }\\
    & h\text{<inj>} \and \hat h(X) = Y
}
$$

## 基数的定义
