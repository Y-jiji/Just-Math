---
TimeLine: 
=> 20220325--20220325 : 创建并完成了大部分内容
---

| #已完成-正文 |
| ------------ |
|              |

# 书写规范

## 文件名

文件名一定要在Obsidian中修改, 否则**反链会出错**!

## 工作规范

不可以添加空文件的依赖! 这会使得工作彻底乱套. 

没有写完的内容要添加上 `#写作中` 标签, 这点非常重要(复制空白模板文件即可)

## 原子性

二级标题下的每一个内容都要具备原子性, 意思是说, 不可能出现分裂的情况. 

二级标题本身尽量不要修改, 如要修改使用rename功能


## 引用

一个文件称为一章, 一个一级标题及其之后内容称为一节, 一个二级标题及其之后内容称为一目. 

同一章当中的知识点之间或者符号之间默认向上引用全部, 不需要另外添加依赖标注. 

不同章之间的知识点之间或者符号之间存在依赖关系的:

- 在一级标题后书写二级标题`::MACRO`, 通过链接标注引用关系; 有引用必加链接, 无引用不加链接. 
- 引用关系精确到二级标题(即使全部使用也要如此), 方便检查和复习. 
- 依赖关系必须是有向无环图, 不得形成环(通过ObsidianGraphView查看和维护, 必要时进行章节拆分). 

```markdown
[引用](./-目录-.md#引用)
```

## 私有目

用 `::` 开头的目称为私有目, 其中的符号不对外部的章公开, 但是在该节内往后的章都适用. 

可以用私有目重载过长的定义来简化记号. 

## 版本管理

通过Git实现版本管理, 每次写完之后都要使用`git add `指令指定书写的内容, 再通过`git commit`描述这次提交. 

## 注解的规范

注解添加在一目的最后数行, 要用RMK表示(Remark的简记). 

## 中外文使用规范

如果是具有实际含义的名词, 就使用中文翻译; 如果是人名, 就使用外文; 

外文使用中, 日本人名使用汉字, 其他人名则以英文表述为准; 

在符号书写中, 不出现汉字(由于LaTeX公式块的汉字支持并不友好); 

## 正文换行

正文换行要用句号或者分号结尾. 

## 等号

等号是指本体论意义下的相等. 

## 下标

下标都是字面值, 例如 $E_n$ 表示的是用 $n$ 去索引 $E$ 而不是用 $n$ 代表的数字索引 $E$

对于一个映射, 或者一个有名元组, 可以用 $f_{(n)}$ 表示 $f(n)$, 可以用 $f_{[n]}$ 表示 $f[n]$. 

## 行内公式

行内公式前后必加空格, 只有一种例外, 就是行内公式和中文放在一起变成一个术语. 例如: $\sigma$代数

## 定义的规范

通过宏定义来定义对象: 

- 参照Haskell中的定义规则, 但是定义符号要使用`:=`来表示. 
- 可以使用Guard(Haskell中为竖线, 此处是用方括号)对定义的情形作限制, 这时被定义标识符可以递归出现在`:=`右侧. 
- 宏定义的语法特征是 : 除非使用Guard, 否则宏定义不会出现在`:=`的右侧

$$
A:=Expr
$$
可以通过宏限制来定义对象: 

- 宏限制表达为`::`, 后面接着的是一个关于被定义项的谓词, 这个谓词必须唯一地刻画被定义项(在同一模型的意义下). 
- 同样, 宏限制也可以带有参数, 关于多态性的描述同上关于宏定义的描述. 
- 宏限制的语法特征是 : 被定义的内容是`::`右侧唯一未被消解的标识符. 

$$
A::Props(A)
$$

## Guard

Guard是一个Haskell中借过来的概念, 表示在不同情况下将标识符理解为不同的表达式, 在这种语义下, 能够在有限次内将被定义标识符消去的递归表达式都是合法的(注意前提是有限次)

在这个库的符号中, Guard的表示是大方括号, 条件后置, 并用 $:::$ 表示

$$
A:=
\Guard{
	& X && :::ConditionX\\
	& Y && :::ConditionY\\
	& A^2 && :::ConditionSquare
}
$$

## 宏启用条件

很多时候我们希望带参数的宏在不同情况下启用不同的定义. 

在定义后, 用 $:::$ 表示宏启用条件, 如果全部符合则替换. 

$$
\begin{matrix}
A:=X\\
:::Condition E\\
:::Condition F
\end{matrix}
$$

宏启用条件中带有非被定义宏参数的参数, 则认为自动挑选适合的语义. 

除此之外, 宏启用条件中不应该存在任何未被使用的参数. 

## 宏启用条件的语法糖

宏启用条件中可以添加一些宏定义或者宏限制来定义的对象, 这些宏定义是私有的, 并将在被解析时最先被替换. 

## 宏消解规则

对同作用域中的每个宏, 总是从下到上进行消解. 这是同名重载合法的原因, 因为替换后同名宏被消解掉了, 之后就将使用更上面的宏来替换这个定义. 

## 行内条件语法

将 $\forall \text{PROPS\_A}(X,Y,\cdots,Z): \text{PROPS\_B}$ 视为
$$
\forall X:\forall Y:\cdots\forall Z:
	\text{PROPS\_A}(X,Y,\cdots,Z)\Rightarrow \text{PROPS\_B}
$$
将 $\exist \text{PROPS\_A}(X,Y,\cdots,Z):\text{PROPS\_B}$ 视为
$$
\exist X:\exist Y:\cdots\exist Z:\text{PROPS\_A}(X,Y,\cdots,Z)\and \text{PROPS\_B}
$$

## 映射与宏的区别

映射有**唯一**确定的定义域和值域, 而对宏来说, 则未必如此(如上一目所说的那样, 宏可能是多态的). 

## 映射签名的规范

如果命题是关于映射的命题, 那么映射的自变量的谓词可以省略, 自动当作在映射外的最内层添加`\forall`. 

映射的签名用冒号来规定, 代表映射所属的类型(注意此处映射未必是从集合到集合的). 

例如 $f:X\to Y$ 是一个三元谓词, 表示 $f$ 是从 $X$ 到 $Y$ 的映射. 

箭头运算符是右结合的, 也就是说形如  $X\to Y\to Z$ 的表达式, 其含义和 $X\to (Y\to Z)$ 相同. 

形如 $f:X\to Y\to Z$ 的表达式, 含义是 $f(x)$ 是类型为 $Y\to Z$ 的函数. 这种语法被称为高阶函数. 

特别地, 如果这个签名中含有未解决的变量, 则理解为

$$
f:\text{A}(X,Y)\to \text{B}(X,Z):=
	\forall X,Y,Z:f|_{\text{A}(X,Y)}:\text A(X,Y)\to \text{B}(X,Z)
$$

## 二元运算的规范

二元运算也是非常常见的语义, 它的定义可以看作一种特殊的映射, 其形式为: `(operator): X\times Y\to Z` 

## 二元运算的幂

例如二元运算符号为$\cdot$, 则二元运算下的幂用 $X^{\cdot r}$ 来表示. 
在序数章节有详细的定义(TODO).  

## 等式推断

等式推断为书写代数问题提供了极大的方便. 

当一个式子中所有自由变量都具备定义域(例如, 出现在某个映射的自变量位置或者具备确定的类型)时, 可以省略这些变量的量词, 量词全部视为任意, 放置于最内层. 

## 类型签名的规范

**类型签名**是一种谓词的**后缀**写法, 代表前面的对象符合这个谓词. 

## 逗号的规范

当且仅当使用后置一元谓词时, 才能使用逗号来代表多个对象符合这个谓词. 

## 命题的规范

当一个命题是公式块下最外层的元素时, 表示该命题是一个定理, 一个猜想, 或者一个定理的证明. 

## 蕴含命题

蕴含命题的书写
- 行间记法 $A \Rightarrow B$ 表示 $A$ 蕴含 $B$
- 块记法
	-  四种谓词(存在X, 存在唯一X, 任意X, 存在且对符合条件的X必有); $\exist X:(\Rightarrow)$ , $\exist!X:(\Rightarrow)$, $\forall X:(\Rightarrow)$, $\#X:(\Rightarrow)$
	-  按条件引入的情况分为两种情况(首行条件, 首行非条件). 

首行条件的记法
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\Field{\forall X:(\Rightarrow)}{\;\;}{
    & \CondBegin\\
    & Condition\\\
    & \CondEnd\\
    & Result\\
    & Another \ Result\\
    & \CondBegin\\
    & Another \ Condition\\
    & \CondEnd\\
    & Again \ Another \ Result
}
$$
首行非条件的记法
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\Field{\forall X:(\Rightarrow)}{\;\;}{
    & \CondEnd\\
    & Result\\
    & Another \ Result\\
    & \CondBegin\\
    & Condition\\
    & \CondEnd\\
    & Again \ Another \ Result
}
$$

## 等价命题, 与命题, 或命题

这三者和量词都没有关系, 只要其中的命题当中没有未解决的谓词即可. 

## 命题的记号

书写命题可以引入下面的记号. 

```latex
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\FieldEndl}[3]{
\left.\begin{aligned}
    & \left.\begin{aligned}
        #1
    \end{aligned}\right.\\
    & \left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
\end{aligned}\right.
}
\newcommand{\Guard}[1]{
\left[~\begin{aligned}
    #1
\end{aligned}\right.
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
```

## 对象模型

称有名元组为对象, 从有名元组中根据字符值取内容的办法有两种, 其一是用 $R[+]$ 记号表示从 $R$ 中取 $+$, 其二是用 $\overset {@R}+$ 表示 $R$ 上的 $+$ 运算, 或者用 $\|a\|_{@ V}$ 表示 $V$ 上的范数运算. 

## 大方括号

下面一组记号表示将 ${\cal C}$ 定义为 ${\cal C}[\Ob]$ 是 $X$, ${\cal C}[\Mor]$ 是 $Y$, 而 ${\cal C}[\Hom]$ 是 $Z$. 

$$
{\cal C}\left[\begin{aligned}
    \Ob &:= X\\
    \Mor &:= Y\\
    \Hom &:= Z\\
\end{aligned}\right]
$$

匿名对象: 下面的记号表示一个匿名对象是交换群, 它以 $G[\S]$ 为 $\S$ 属性的值, 以 $G[\cdot]$ 为 $+$ 属性的值. 

$$
\text{ab-group}
\left[\begin{aligned}
    \S &:= G[\S]\\
    (+) &:= G[\cdot]\\
\end{aligned}\right]
$$

## 代数板块内容安排

讨论态射总是先给出定义, 再在范畴里初步讨论, 再之后分章节来讨论. 起名的时候一般起某某范畴和态射的类型签名的中文名字. 

讨论环的理想, 正规子群之类子结构的时候, 总是先讨论成为态射的商映射的形态, 再讨论这些子结构的定义. 

## 示性函数

遵从计算机科学中的惯例, Boolean类型的值在为False时视为0, 为True时视为1. 

