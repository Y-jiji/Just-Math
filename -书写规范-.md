---
TimeLine: 
=> 20220325--20220325 : 创建并完成了大部分内容
---

| #未完成-正文 | #写作中 |
| ------------ | ------- |
|              |         |

# 书写规范

## 目录

先写目录再书写内容. 

目录中开始写作但未完成的项用`[+]`表示, 未开始项用`[ ]`表示, 已完成项用`[o]`表示. 

## 文件名

文件名一定要在Obsidian中修改, 否则**反链会出错**!

## 工作规范

不可以添加空文件的依赖! 这会使得工作彻底乱套. 

没有写完的内容要添加上 `#写作中` 标签, 这点非常重要(复制空白模板文件即可)

## 原子性

二级标题下的每一个内容都要具备原子性, 意思是说, 不可能出现分裂的情况. 

二级标题本身尽量不要修改. 

## 引用

一个文件称为一章, 一个一级标题及其之后内容称为一节, 一个二级标题及其之后内容称为一目. 

同一章当中的知识点之间或者符号之间默认向上引用全部, 不需要另外添加依赖标注. 

不同章之间的知识点之间或者符号之间存在依赖关系的:

- 在一级标题后书写二级标题`::MACRO`, 通过链接标注引用关系; 有引用必加链接, 无引用不加链接. 
- 引用关系精确到二级标题(即使全部使用也要如此), 方便检查和复习. 
- 依赖关系必须是有向无环图, 不得形成环(通过ObsidianGraphView查看和维护, 必要时进行章节拆分). 

```markdown
[引用](./-目录-.md#引用)
```

## 版本管理

通过Git实现版本管理, 每次写完之后都要使用`git add `指令指定书写的内容, 再通过`git commit`描述这次提交. 

## 注解的规范

注解添加在一目的最后数行, 要用RMK表示(Remark的简记). 

## 中外文使用规范

如果是具有实际含义的名词, 就使用中文翻译; 如果是人名, 就使用外文; 

外文使用中, 日本人名使用汉字, 其他人名则以英文表述为准; 

在符号书写中, 不出现汉字(由于LaTeX公式块的汉字支持并不友好); 

## 正文换行

正文换行要用句号或者分号结尾. 

## 行内公式

行内公式前后必加空格, 只有一种例外, 就是行内公式和中文放在一起变成一个术语. 例如: $\sigma$代数

## 定义的规范

通过宏定义来定义对象: 

- 参照Haskell中的定义规则, 但是定义符号要使用`:=`来表示. 
- 可以使用Guard(Haskell中为竖线, 此处是用方括号)对定义的情形作限制, 这时被定义标识符可以递归出现在`:=`右侧. 
- 宏定义的语法特征是 : 除非使用Guard, 否则宏定义不会出现在`:=`的右侧

$$
A:=Expr
$$
可以通过宏限制来定义对象: 

- 宏限制表达为`::`, 后面接着的是一个关于被定义项的谓词, 这个谓词必须唯一地刻画被定义项(在同一模型的意义下). 
- 同样, 宏限制也可以带有参数, 关于多态性的描述同上关于宏定义的描述. 
- 宏限制的语法特征是 : 被定义的内容是`::`右侧唯一未被消解的标识符. 

$$
A::Props(A)
$$

## Guard

Guard是一个Haskell中借过来的概念, 表示在不同情况下将标识符理解为不同的表达式, 在这种语义下, 能够在有限次内将被定义标识符消去的递归表达式都是合法的(注意前提是有限次)

在这个库的符号中, Guard的表示是大方括号, 条件后置, 并用 $:::$ 表示

$$
A:=
\Guard{
	& X && :::ConditionX\\
	& Y && :::ConditionY\\
	& A^2 && :::ConditionSquare
}
$$

## 宏启用条件

很多时候我们希望带参数的宏在不同情况下启用不同的定义. 

在定义后, 用 $:::$ 表示宏启用条件, 如果全部符合则替换. 

$$
\begin{matrix}
A:=X\\
:::Condition E\\
:::Condition F
\end{matrix}
$$

## 字面值下标的规范: 定义项

对于类型相同的两个代数结构而言, 经常需要表示其上的二元运算, 然而如果这两个代数结构架设在同一集合上, 对同一标识符却具有不同的运算, 这时就会出现矛盾, 需要确切指出运算是哪种意义下的运算, 这种时候就需要字面值下标来救场了. 

使用带有字面值参数的宏有两种方法, 第一种是先声明个别位置参数上使用宏, 而后再使用, 另一种则是直接在某个位置上的参数前添加 $\$$ 标记. 

第一种情况例如在拓扑一章中的 $\text{<top-space>}$

$$
X\text{<top-space>}:=
\Field{
    (\and)    
}{\;\;}{\\
    & X\text{<set>}\\\\
    & \tau_{\$}\\
    & \tau_{X}\in {\frak P}({\frak P}(X))\\
    & X=\bigcup_{E\in \tau_X}E\\
    & \tau_X\text{<topology>}\\\\
}
$$

第二种情况例如拓扑一章中的 $\text{Interior}$

$$
\begin{matrix}
\text{Interior}_{\$X}(E)
    :=\bigg\{
        x\in X:
        \exist U\in {\frak U}_{X}(x):
            U\sube E
    \bigg\}\\

\begin{aligned}
    & :::X\text{<top-space>}\\
    & :::E\text{<set>}\\
    & ::: E\sube X
\end{aligned}
\end{matrix}
$$

字面值下标的含义并不是一个宏, 而是在调用时将某个宏在作用域内绑定到这个字面值上, 使得兼容其原语义的同时添加一些其他的内容. 

之后在任何场合使用这个标识符的时候, 都是在使用它加上这些宏形成的有名元组. 

## 集合指标绑定

和字面值下标的动机相同, 当我们希望在代数结构中的某些元素进行运算时, 省略运算之上的指标, 而直接进行元素的运算. 

在这类问题当中, 我们的思维会自然地为一个元素绑定一个代数结构. 怎么把它转化为符号语言呢, 我们使用 $\overset\sim\in$ 来表示这样的特殊语义.  
$$
x\overset{\sim}\in X
$$

使用这样语义的时候, 任何施加在 $x$ 上的运算, 将把 $X$ 放置在其指标位置. 

例如 $x,y\overset{\sim}\in X$ , 而 $X$ 是一个群时, 可以不使用 $\overset{X}\cdot$, 而使用 $x\cdot y$ 来调用 $X$ 上的乘法. 

例如 $k\overset{\sim}\in {\mathbb K}\and v \overset{\sim}\in V$,  而 $V$ 是 ${\mathbb K}$ 上的线性空间时, $k\cdot v$ 就表示 $k\overset{{\mathbb K},V}\cdot v$

## 映射指标绑定

用 $\wr$ 代替 $:$ 来表示带运算绑定的映射. 



## 映射与宏的区别

映射有**唯一**确定的定义域和值域, 而对宏来说, 则未必如此(如上一目所说的那样, 宏可能是多态的). 

## 映射签名的规范

如果命题是关于映射的命题, 那么映射的自变量的谓词可以省略, 自动当作在映射外的最内层添加`\forall`. 

映射的签名用冒号来规定, 代表映射所属的类型(注意此处映射未必是从集合到集合的). 

例如 $f:X\to Y$ 是一个作用于 $f$ 的谓词, 表示 $f$ 是从 $X$ 到 $Y$ 的映射. 

箭头运算符是右结合的, 也就是说形如  $X\to Y\to Z$ 的表达式, 其含义和 $X\to (Y\to Z)$ 相同. 

形如 $f:X\to Y\to Z$ 的表达式, 含义是 $f(x)$ 是类型为 $Y\to Z$ 的函数. 这种语法被称为高阶函数. 

当定义域和值域也是映射时, 可以也可以省略自变量的谓词; 

例如 $f:A(X,Y)\to B(Y)$ 表示 $\forall X,Y:f|_{A(X,Y)}:A(X,Y)\to B(Y)$ 并且 $f:\bigcup\limits_{X,Y}A(X,Y)\to \bigcup\limits_{X,Y}B(Y)$

## 二元运算的规范

二元运算也是非常常见的语义, 它的定义可以看作一种特殊的映射, 其形式为: `(operator): X\times Y\to Z` 

## 类型签名的规范

**类型签名**是一种谓词的**后缀**写法, 代表前面的对象符合这个谓词. 

## 命题的规范

当一个命题是公式块下最外层的元素时, 表示该命题是一个定理, 一个猜想, 或者一个定理的证明. 

## 蕴含命题

蕴含命题的书写
- 行间记法 $A \Rightarrow B$ 表示 $A$ 蕴含 $B$
- 块记法
	-  四种谓词(存在X, 存在唯一X, 任意X, 存在且对符合条件的X必有); $\exist X:(\Rightarrow)$ , $\exist!X:(\Rightarrow)$, $\forall X:(\Rightarrow)$, $\#X:(\Rightarrow)$
	-  按条件引入的情况分为两种情况(首行条件, 首行非条件). 

首行条件的记法
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\Field{\forall X:(\Rightarrow)}{\;\;}{
    & \CondBegin\\
    & Condition\\\
    & \CondEnd\\
    & Result\\
    & Another \ Result\\
    & \CondBegin\\
    & Another \ Condition\\
    & \CondEnd\\
    & Again \ Another \ Result
}
$$
首行非条件的记法
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\Field{\forall X:(\Rightarrow)}{\;\;}{
    & \CondEnd\\
    & Result\\
    & Another \ Result\\
    & \CondBegin\\
    & Condition\\
    & \CondEnd\\
    & Again \ Another \ Result
}
$$

## 等价命题, 与命题, 或命题

这三者和量词都没有关系, 只要其中的命题当中没有未解决的谓词即可. 

## 命题的记号

书写命题可以引入下面的记号. 

```latex
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\FieldEndl}[3]{
\left.\begin{aligned}
    & \left.\begin{aligned}
        #1
    \end{aligned}\right.\\
    & \left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
\end{aligned}\right.
}
\newcommand{\Guard}[1]{
\left[~\begin{aligned}
    #1
\end{aligned}\right.
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\newcommand{\SimIn}{\overset{\sim}{\in}}
\newcommand{\SimNi}{\overset{\backsim}{\ni}}
```

