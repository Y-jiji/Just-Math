# 书写规范

## 目录

先写目录再书写内容. 

目录中开始写作但未完成的项用`[+]`表示, 未开始项用`[ ]`表示, 已完成项用`[o]`表示. 

## 工作规范

不得有三个及以上文件同时处于`[+]`状态. 这么做是为了方便维护引用, 参看下一目. 

然而, 有一些片段可以放置在Draft文件夹中等待取用. 

已经开始但未完成的文件之前需要添加`+`记号, 使得它置顶. 

已完成但仍有依赖未解决的文件需要添加`$`记号, 同样使得它置顶. 

## 引用

一个文件称为一章, 一个一级标题及其之后内容称为一节, 一个二级标题及其之后内容称为一目. 

同一章当中的知识点之间或者符号之间默认向上引用全部, 不需要另外添加依赖标注. 

不同章之间的知识点之间或者符号之间存在依赖关系的:

- 在一级标题后书写二级标题`::IMPORT`, 通过链接标注引用关系; 有引用必加链接, 无引用不加链接. 
- 引用关系精确到一级标题(即使全部使用也要如此), 方便检查和复习. 
- 依赖关系必须是有向无环图, 不得形成环(通过Obsidian查看和维护, 必要时进行章节拆分). 

```markdown
[-目录-.md/目录](./-目录-.md#目录)
```

## 符号表

每节中书写二级标题`::EXPORT`, 通过链接标注每一目中各定义了什么记号, 或证明了什么定理. 

## 版本管理

通过Git实现版本管理, 每次写完之后都要使用`git add `指令指定书写的内容, 再通过`git commit`描述这次提交. 

## 注解的规范

注解添加在一目的最后数行, 要用RMK表示(Remark的简记). 

## 中外文使用规范

如果是具有实际含义的名词, 就使用中文翻译; 如果是人名, 就使用外文; 

外文使用中, 日本人名使用汉字, 其他人名则以英文表述为准; 

在符号书写中, 不出现汉字(由于LaTeX公式块的汉字支持并不友好); 

## 正文换行

正文换行要用句号或者分号结尾. 

## 行内公式

行内公式前后必加空格. 

## 定义的规范

通过宏定义来定义对象: 

- 参照Haskell中的定义规则, 但是定义符号要使用`:=`来表示. 
- 可以使用Guard(Haskell中为竖线, 此处是用方括号)对定义的情形作限制, 这时被定义标识符可以递归出现在`:=`右侧. 
- 宏可以是宏函数, 这种情况下同一个宏可以具备多态性, 此时需要`:::`算符限制自变量的范围, 自变量范围匹配时, 启用这个定义, 否则不启用这个定义; 不得有多个`:::`后的部分相同但定义项又不同的宏. 

可以通过宏限制来定义对象: 

- 宏限制表达为`::`, 后面接着的是一个关于被定义项的谓词, 这个谓词必须唯一地刻画被定义项(在同一模型的意义下). 
- 同样, 宏限制也可以是宏函数, 关于多态性的描述同上关于宏定义的描述. 

## 映射与宏的区别

映射有**唯一**确定的定义域和值域, 而对宏来说, 则未必如此(如上一目所说的那样, 宏可能是多态的). 

## 映射签名的规范

如果命题是关于映射的命题, 那么映射的自变量的谓词可以省略, 自动当作在映射外的最内层添加`\forall`. 

映射的签名用冒号来规定, 代表映射所属的类型(注意此处映射未必是从集合到集合的). 

例如 $f:X\to Y$ 是一个作用于 $f$ 的谓词, 表示 $f$ 是从 $X$ 到 $Y$ 的映射. 

箭头运算符是右结合的, 也就是说形如  $X\to Y\to Z$ 的表达式, 其含义和 $X\to (Y\to Z)$ 相同. 

形如 $f:X\to Y\to Z$ 的表达式, 含义是 $f(x)$ 是类型为 $Y\to Z$ 的函数. 这种语法被称为高阶函数. 

当定义域和值域也是映射时, 可以也可以省略自变量的谓词; 

例如 $f:A(X,Y)\to B(Y)$ 表示 $\forall X,Y:f|_{A(X,Y)}:A(X,Y)\to B(Y)$ 并且 $f:\bigcup\limits_{X,Y}A(X,Y)\to \bigcup\limits_{X,Y}B(Y)$

## 二元运算的规范

二元运算也是非常常见的语义, 它的定义可以看作一种特殊的映射, 其形式为: `(operator): X\times Y\to Z` 

## 类型签名的规范

类型签名是一种谓词的后缀写法, 代表前面的对象符合这个谓词. 

## 字面值下标的规范

对于类型相同的两个代数结构而言, 经常需要表示其上的二元运算, 然而如果这两个代数结构架设在同一集合上, 对同一标识符却具有不同的运算, 这时就会出现矛盾, 需要确切指出运算是哪种意义下的运算, 这种时候就需要字面值下标来救场了. 

字面值的含义是, 即使两者指代相同的对象, 两者的字面值也不相同. 

当在定义项中使用 $G\$$ 时, 代表的是使用左侧标识符 $G$ 的字面值, 而不是 $G$ 所指代的宏定义. 

例如在群论中定义群的时候, 是这样进行表述的: 
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\Field{
    G\text{<grp>}::
}{\;\;}{
    & G\text{<set>}\\
    & (\overset{G\$}\cdot) : G\times G\to G\\
    & \cdots\cdots\\
}
$$
在使用群的概念时, 直接在使用 $\overset{G}\cdot$ 代表 $G$ 上定义的运算, 使用  $\overset{H}\cdot$ 代表 $H$ 上定义的运算. 

## 命题的规范

当一个命题是公式块下最外层的元素时, 表示该命题是一个定理, 一个猜想, 或者一个定理的证明. 

## 蕴含命题

蕴含命题的书写

- 行间记法 $A \Rightarrow B$ 表示 $A$ 蕴含 $B$
- 块记法

    -     四种谓词(存在X, 存在唯一X, 任意X, 存在且对符合条件的X必有); $\exist X:(\Rightarrow)$ , $\exist!X:(\Rightarrow)$, $\forall X:(\Rightarrow)$, $\#X:(\Rightarrow)$
    -     按条件引入的情况分为两种情况(首行条件, 首行非条件). 

首行条件的记法
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\Field{\forall X:(\Rightarrow)}{\;\;}{
    & \CondBegin\\
    & Condition\\\
    & \CondEnd\\
    & Result\\
    & Another \ Result\\
    & \CondBegin\\
    & Another \ Condition\\
    & \CondEnd\\
    & Again \ Another \ Result
}
$$
首行非条件的记法
$$
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
\Field{\forall X:(\Rightarrow)}{\;\;}{
    & \CondEnd\\
    & Result\\
    & Another \ Result\\
    & \CondBegin\\
    & Condition\\
    & \CondEnd\\
    & Again \ Another \ Result
}
$$

## 等价命题, 与命题, 或命题

这三者和量词都没有关系, 只要其中的命题当中没有未解决的谓词即可. 

## 命题的记号

书写命题可以引入下面的记号. 

```latex
\newcommand{\Field}[3]{
    #1\left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
}
\newcommand{\FieldEndl}[3]{
\left.\begin{aligned}
    & \left.\begin{aligned}#1\end{aligned}\right.\\
    & \left|\underline{\overline{#2\begin{aligned}
       #3
    \end{aligned}#2}}\right|
\end{aligned}\right.
}
\newcommand{\Guard}[1]{
\left[~\begin{aligned}
    #1
\end{aligned}\right.
}
\newcommand{\CondBegin}{{\lhd}\,{\lhd}\,{\lhd}}
\newcommand{\CondEnd}{{\rhd}\,{\rhd}\,{\rhd}}
```

