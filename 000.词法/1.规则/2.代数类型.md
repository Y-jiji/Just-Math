---
20220729--0000000 : 章节已创建
---
# 代数类型

> 在这个文档中, 我们介绍 $\data$ 关键字(如果熟悉Haskell语言, 这一部分可以略读). 
> 另外, 尽管我们并不愿意这么做, 本章中还会引入 $\Bool$ 类型. 

## RoadMap
- [ ] 类模板是类型的函数
- [ ] 终点是单例类型的类型一定是单例类型
- [ ] $\cls$ 关键字

## 子类型 [SYM]
::::文字::::
对两个类型 $\sf A$ 和一个类型 $\sf B$ 来说, 如果如果一个数据是 ${\sf A}$ 类型, 则它一定是 $\sf B$ 类型, 则称 $\sf A$ 为 $\sf B$ 的子类. 

## $\mid$ 连接符 [SYM]
::::文字::::
用 $\mid$ 连接符连接 ${\sf A}$ 和 ${\sf B}$ 两个类型将创造一个 ${\sf A}$ 和 ${\sf B}$ 的父类. 一个数据是 ${\sf A\mid B}$ 类型的, 当且仅当它是 ${\sf A}$ 类型的或者是 ${\sf B}$ 类型的. 
根据以上描述, 我们很容易证明, $\sf A \mid B$ 和 $\sf B \mid A$ 是同一类型, 因为判定属于该类型的方法是一样的. 
并且经过简单推衍, 容易发现 $\mid$ 算符也符合结合律, 这意味着可以不使用括号来规定运算顺序. 
规定 $\mid$ 连接符的优先级低于接下来介绍的 $\to$ 连接符. 

## $\to$ 连接符 [SYM]
::::文字::::
用 $\to$ 连接符连接 ${\sf A}$ 和 ${\sf B}$ 两个类型得到 ${\sf A\to B}$ , 这表示任何一个输入类型 ${\sf A}$ , 输出类型 ${\sf B}$ 的函数的类型. 
如果 ${\sf A}$ 是 ${\sf B}$ 的子类, 那么 ${\sf B} \to {\sf C}$ 是 ${\sf A} \to {\sf C}$ 的子类. 
这看似难以理解, 然而如此解释应当了了: 任何能够应用在 ${\sf A}$ 上的函数一定能应用在 ${\sf B}$ 上, 因此 ${\sf A \to \sf C}$ 类型的应用范围比 ${\sf B \to C}$ 广. 
如果 $\sf B$ 是 $\sf C$ 的子类, 那么 $\sf A \to B$ 是 $\sf A \to C$ 的子类, 这应当是自然的. 
我们规定 $\to$ 连接符是右结合的, 即 $\sf A \to B \to C$ 表示 $\sf A \to (B \to C)$ . 

## $\cons$ 关键字 [SYM]
::::文字::::
构造子按照标识符的字面值进行区分, 也就是说, 两个构造子相同, 当且仅当它们标识符的字面值相同. 
同一个构造子对应一种函数类型; 对任意的两组相同或不同的输入, 应用两个不同的构造子之间产生的值一定不同. 
使用 $\cons$ 声明的构造子, 其标识符要么是 `\tt` 体的大写开头的字母串, 要么是单个特殊符号. 
例子: 声明 ${\tt Cons}$ 为一个构造子, 其中两个下划线表示它获取两个输入: 
$$
\cons:{\tt Cons}\;\_\;\_
$$
没有任何输入的构造子称为原子类型, 它是最简单的数据类型. 正如名字所说的那样, 它不能是两个类型之间的函数类型, 也不能是两个类型的并. 
原子类型的值只有一个, 它是单例类型, 但它并不能和单例类型相混淆. 
反例: 如果 $\tt A$ 和 $\tt B$ 都是原子类型, 那么 ${\tt A \to B}$ 也是单例类型, 但它显然不是原子类型. 

## $\data$ 关键字 [SYM]
::::文字::::
理解了上述5个概念, 便充分理解了代数类型. $\data$ 关键字只是将上面的五个概念应用了一番, 我们可以使用 $\data$ 声明复合类型和类型模板. 
使用 $\data$ 声明的类型或类型模板, 其标识符要么是 `\sf` 体的大写开头的字母串, 要么是单个特殊符号. 
如果声明所得的内容是单例类型, 并且标识符是字母串, 则应该为 `\tt` 体的大写开头的字母串. 
例子: 先声明 $\tt Nil$ 和 ${\tt Cons}$ 两个构造子, 而后声明 $\List{\rm T}$ 可以通过 ${\tt Cons}$ 连接 ${\rm T}$ 类型和另一个 $\List{\rm T}$ 来构造. 
$$
\begin{aligned}
& \cons:{\tt Nil}\\
& \cons:{\tt Cons}\;\_\;\_\\
& \data:\List{\rm T} := {\tt Cons}\;{\rm T}\;\List{\rm T} \mid {\tt Nil}
\end{aligned}
$$
::::注记::::
这里我们对命名的规则做一个总结: 
- 如果一个标识符是 `\tt` 或 `\sf` 体的字母串, 则当且仅当这个标识符能表示数据类型时, 这个标识符是大写字母开头. 
- 一个标识符是 `\tt` 体的, 当且仅当这个标识符能表示一个单例的数据(单例数据, 或其他). 

## $\Bool$ 类型 [SYM]
::::文字::::
尽管并不情愿, 这里还是需要定义一个基础的类型, 否则我们将无法使用强大的 $\meta$ 语义. 
::::形式::::
$$
\begin{aligned}
    & \cons:\True\\
    & \cons:\False\\
    & \data:\Bool:=\True \mid \False
\end{aligned}
$$

## 单例类型的判定 [SYM]
::::文字::::
终点是单例类型的类型一定是单例类型. 

## 类模板是类型的函数 [SYM]
::::文字::::
类模板可以看作类型的函数, 其接收数个类型, 返回一个类型. 
......
类模板当中也可以应用模式匹配的技巧. 
......

## 单例类型的等号 [SYM]
::::文字::::
单例类型取等号, 当且仅当其类型完全相同. 

## $\cls$ 关键字 [SYM]
::::文字::::
$\cls$ 关键字根据一个谓词产生一种类型. 所谓谓词就是 ${\rm T}\to\Bool$ 类型的函数 $f$ . 使得 $f$ 为 $\True$ 的 $\rm T$ 即 $\cls\;f$ 类型的元素. 







